<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Q-Engine,Q-Engine@gmail.com"><title>安卓性能之CPU学习总结 · Hexo</title><meta name="description" content="CPU架构CPU：中央处理器。功能主要是解释计算机指令以及处理计算机软件中的数据。主要包括运算器（算术逻辑运算单元ALU）和高速缓冲存储器（Cache）及实现它们之间联系的数据（Data）、控制及状态的总线（Bus）。目前市面上的CPU分类主要分有两大阵营：以intel、AMD为首的复杂指令集CPU"><meta name="keywords" content="Q-Engine,Vue,HTML,CSS,Android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"><meta name="generator" content="Hexo 6.3.0"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">Hexo</a></h3><div class="description"><p>Mars,here we come!!</p></div></div></div><ul class="social-links"></ul></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">Home</a></li><li><a href="/about">Sobre</a></li><li><a href="/archives">Archivo</a></li><li><a href="/links">Enlaces</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/headpic.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>安卓性能之CPU学习总结</a></h3></div><div class="post-content"><h2 id="CPU架构"><a href="#CPU架构" class="headerlink" title="CPU架构"></a>CPU架构</h2><p>CPU：中央处理器。功能主要是解释计算机指令以及处理计算机软件中的数据。主要包括运算器（算术逻辑运算单元ALU）和高速缓冲存储器（Cache）及实现它们之间联系的数据（Data）、控制及状态的总线（Bus）。<br>目前市面上的CPU分类主要分有两大阵营：以intel、AMD为首的复杂指令集CPU；以IBM、ARM为首的精简指令集CPU。Intel、AMD的CPU是X86架构的，而IBM公司的CPU是PowerPC架构，ARM公司是ARM架构。电脑CPU用的是复杂指令系统（CISC），而手机CPU则是精简指令系统（RISC）。<br>CPU中指令集与微架构的区别看以下文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/19893066">https://zhuanlan.zhihu.com/p/19893066</a><br>以下链接查看Linux、安卓中查看CPU信息的方法：<br><a target="_blank" rel="noopener" href="http://t.csdn.cn/h48NC">http://t.csdn.cn/h48NC</a></p>
<h2 id="核心频率"><a href="#核心频率" class="headerlink" title="核心频率"></a>核心频率</h2><p>现在的CPU架构一般是大小核架(或大中小核架构)，CPU一般采用8核心，CPU 0-3一般是小核心，CPU 4-7一般是大核心。小核心一般来说主频低，功耗也低，使用的一般是 arm A5X 系列，比如高通骁龙 845，小核心是由四个 A55 (最高主频 1.8GHz ) 组成；大核心一般来说最高主频比较高，功耗相对来说也会比较高，使用的一般是 arm A7X 系列，比如高通骁龙 845，大核心就是由四个 A75（最高主频 2.8GHz）组成。<br>CPU的频点范围是指CPU在运行过程中所能达到的最低和最高工作频率。<br>为什么要分大小核而不是一个核心通过调频适用不同场景呢？因为小核的能效比比大核的要更高。如下图电脑CPU能效曲线所示:在活不重的时候m1 pro再怎么降频也不如m1效率高（红圈）;而负荷增加到一定程度之后，m1再怎么超频也不如m1 pro有更高的效率（绿圈）。</p>
<p><img src="/../images/%E5%AE%89%E5%8D%93%E6%80%A7%E8%83%BD%E4%B9%8BCPU%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E7%94%B5%E8%84%91CPU%E8%83%BD%E6%95%88%E6%9B%B2%E7%BA%BF.jpg"><br>每个CPU的频率上下限的可以在systrace中点击Clock Frequency Limits查看。一般来讲：小核频率一般小于2GHz，中核频率一般小于2.5Ghz，大核频率一般大于2.5GHz。<br>Systrace的CPU info的C-State又4个值，各个值表示的含义如下所示：</p>
<ol>
<li>C0 状态（激活）<br>这是 CPU 最大工作状态，在此状态下可以接收指令和处理数据；<br>所有现代处理器必须支持这一功耗状态。</li>
<li>C1 状态（挂起）<br>可以通过执行汇编指令“ HLT （挂起）”进入这一状态；<br>唤醒时间超快！（快到只需 10 纳秒！）；<br>可以节省 70% 的 CPU 功耗；<br>所有现代处理器都必须支持这一功耗状态。</li>
<li>C2 状态（停止允许）<br>处理器时钟频率和 I&#x2F;O 缓冲被停止；<br>换言之，处理器执行引擎和 I&#x2F;0 缓冲已经没有时钟频率；<br>在 C2 状态下也可以节约 70% 的 CPU 和平台能耗；<br>从 C2 切换到 C0 状态需要 100 纳秒以上。</li>
<li>C3 状态（深度睡眠）<br>总线频率和 PLL 均被锁定；<br>在多核心系统下，缓存无效；<br>在单核心系统下，内存被关闭，但缓存仍有效可以节省 70% 的 CPU 功耗，但平台功耗比 C2 状态下大一些；<br>唤醒时间需要 50 微妙。</li>
</ol>
<h2 id="对比机选择原则"><a href="#对比机选择原则" class="headerlink" title="对比机选择原则"></a>对比机选择原则</h2><ol>
<li>选择已经之前完成调试的机器；</li>
<li>测试机与对比机的相关配置尽量相同，例如CPU的型号、App的运行环境、手机系统一致；</li>
<li>选择市面上其它厂商的竞争机作为对比机，要求性能优化达到竞争机的水平。</li>
</ol>
<h2 id="CPUSet"><a href="#CPUSet" class="headerlink" title="CPUSet"></a>CPUSet</h2><p>CPUSet的作用：用来将进程绑定到指定的CPU上，用于修改task的cpu核亲和度。以下为不同CPUSet参数的含义：</p>
<p><img src="/../images/%E5%AE%89%E5%8D%93%E6%80%A7%E8%83%BD%E4%B9%8BCPU%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E4%B8%8D%E5%90%8CCPUset%E7%9A%84%E5%90%AB%E4%B9%89.jpg"><br>手机查看CPUSet分组的命令参考以下文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/forrest-lin/p/14608744.html">https://www.cnblogs.com/forrest-lin/p/14608744.html</a><br>进程绑定CPU的原理是：将进程绑定到某个 CPU 只是将进程放置到 CPU 的可运行队列中。具体调用函数参考以下文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/388356797">https://zhuanlan.zhihu.com/p/388356797</a></p>
<h2 id="TestSet"><a href="#TestSet" class="headerlink" title="TestSet"></a>TestSet</h2><p>通过 taskset 命令可将某个进程与某个CPU核心绑定，使得其仅在与之绑定的CPU核心上运行。以下为其基本语法格式：<code>taskset [参数] CPU核心号 进程号(PID)</code>。以下为基本参数：</p>
<p><img src="/../images/%E5%AE%89%E5%8D%93%E6%80%A7%E8%83%BD%E4%B9%8BCPU%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/taskset%E5%91%BD%E4%BB%A4.jpg"><br>更具体的用法参考以下文章：<a target="_blank" rel="noopener" href="https://www.linuxcool.com/taskset">https://www.linuxcool.com/taskset</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/test1280/article/details/87991302">https://blog.csdn.net/test1280/article/details/87991302</a></p>
<h2 id="affinity"><a href="#affinity" class="headerlink" title="affinity"></a>affinity</h2><p>在多CPU系统中，通过sched_setaffinity()可以设置进程的CPU亲和力，使进程绑定在某一个或几个CPU上运行，避免在CPU之间来回切换，从而提高该进程的实时性能。其系统调用的 taskset。具体的设置语法参考下面的文章：<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/38541212">https://zhuanlan.zhihu.com/p/38541212</a></p>
<h2 id="performance-mode-性能模式设置"><a href="#performance-mode-性能模式设置" class="headerlink" title="performance mode(性能模式设置)"></a>performance mode(性能模式设置)</h2><p>在Linux中，内核的开发者定义了一套框架模型来完成CPU频率动态调整这一目的，它就是CPU Freq系统。可以设置CPU的几种模式，例如：powersave、performance、ondemand等模式，各种CPU模式的含义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">1. ondemand：系统默认的超频模式，按需调节，内核提供的功能，不是很强大，但有效实现了动态频率调节，平时以低速方式运行，当系统负载提高时候自动提高频率。以这种模式运行不会因为降频造成性能降低，同时也能节约电能和降低温度。一般官方内核默认的方式都是ondemand。 </span><br><span class="line">2. interactive：交互模式，直接上最高频率，然后看CPU负荷慢慢降低，比较耗电。Interactive 是以 CPU 排程数量而调整频率，从而实现省电。InteractiveX 是以 CPU 负载来调整 CPU 频率，不会过度把频率调低。所以比 Interactive 反应好些，但是省电的效果一般。 </span><br><span class="line">3. conservative：保守模式，类似于ondemand，但调整相对较缓，想省电就用他吧。Google官方内核，kang内核默认模式。 </span><br><span class="line">4. smartass：聪明模式，是I和C模式的升级，该模式在比interactive 模式不差的响应的前提下会做到了更加省电。 </span><br><span class="line">5. performance：性能模式！只有最高频率，从来不考虑消耗的电量，性能没得说，但是耗电量。 </span><br><span class="line">6. powersave 省电模式，通常以最低频率运行。 </span><br><span class="line">7. userspace：用户自定义模式，系统将变频策略的决策权交给了用户态应用程序，并提供了相应的接口供用户态应用程序调节CPU 运行频率使用。也就是长期以来都在用的那个模式。可以通过手动编辑配置文件进行配置 </span><br><span class="line">8. Hotplug：类似于ondemand, 但是cpu会在关屏下尝试关掉一个cpu，并且带有deep sleep，比较省电。</span><br></pre></td></tr></table></figure>

<p>查看电脑CPU当前的工作模式：<code>cat /sys/devices/system/cpu/cpu*/cpufreq/scaling_governor</code>。如果没有启用高性能模式一般为：powersave。改变模式的方法请看以下文章：<br><a target="_blank" rel="noopener" href="https://blog.csdn.net/zaf0516/article/details/95769589">https://blog.csdn.net/zaf0516/article/details/95769589</a><br><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/e1a37771c68e">https://www.jianshu.com/p/e1a37771c68e</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/Heimerdinger_Feng/article/details/79126365">https://blog.csdn.net/Heimerdinger_Feng/article/details/79126365</a><br>设置CPU的min&#x2F;max 频率的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo cpufreq-set -d 1800m -u 2700m //适用模式：powersave|ondemand|conservative|performance</span><br><span class="line">sudo cpufreq-set -f &#123;1800m~2700m&#125; //适用模式：userspace</span><br><span class="line">-d 设置最小频率   -u 设置最大频率</span><br></pre></td></tr></table></figure>

<h2 id="安卓powerHalService"><a href="#安卓powerHalService" class="headerlink" title="安卓powerHalService"></a>安卓powerHalService</h2><p>搜索后并没有相关的文章结束powerHalService，询问GPT后说这个是电源管理策略：PowerHalService是Android系统中的一个服务，用于管理设备的电源管理策略。PowerHAL是一个硬件抽象层，用于管理和控制设备的功耗和性能。具体的有关电源管理的文章如下：<a target="_blank" rel="noopener" href="https://blog.csdn.net/he980725866/article/details/113747765">https://blog.csdn.net/he980725866/article/details/113747765</a></p>
<h2 id="Eas"><a href="#Eas" class="headerlink" title="Eas"></a>Eas</h2><p>能量感知调度（Energy Aware Scheduling，简称EAS）是目前Android手机中Linux线程调度器的基础功能，它使调度器能预测其决策对CPU能耗的影响。依靠CPU的能量模型（Energy Model，简称EM），EAS能为每个线程选择一个最能节约能量的CPU，并把对系统性能的影响降到最低。<br>EAS 是一个大的project，由 linaro 组织在 2014 年发起的项目，这个项目目的是开发出一套适用于移动设备的 cpu 调度和调频方案，因此项目中分了三个大方向进行研究，分别是 scheduler，cpuidle，和 cpufreq。而你说的 schedutil 就是 cpufreq 方向的一个产物。 然而我们通常把在 scheduler 方向的研究成果通称为 EAS 调度器，意思是功耗感知调度器。 在 cpuidle 方向的研究成果没有独立的模块，只是在 EAS 调度器中会去参考 cpuidle 的功耗，最终反映到整个 EAS 调度器里。 所以从他们的研究成果来看，schedutil 和 EAS 都是可以单独拿出来说，一个关注于 cpufreq，另一个关注于 scheduler。 如果硬是要把他们联系在一起，可以认为 EAS 是强化了 schedutil 的能力，使得 cpu 频率调节更精准了。<br>EAS只在系统负载不重时，即系统中每个CPU的利用率都低于其算力的80%时才被启用，而且选出的最节能CPU只有比线程当前运行的CPU节约能量大于6%时，线程才会迁移到该CPU运行。因此EAS为线程选择最节约能量的CPU来运行的前提条件是很苛刻的，针对重载场景（比如游戏），EAS的功能应该很少被使用起来，针对重载场景的功耗优化，这里可能是一个值得尝试的点。<br>具体的Eas的实现以及算法参考以下文章:<br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/626701969(%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E6%9C%89%E8%AE%B8%E5%A4%9A%E4%B8%8Elinux%E5%86%85%E6%A0%B8%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BC%98%E8%89%AF%E6%96%87%E7%AB%A0%E9%93%BE%E6%8E%A5)">https://zhuanlan.zhihu.com/p/626701969(这篇文章有许多与linux内核相关的优良文章链接)</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/rikeyone/article/details/88342382">https://blog.csdn.net/rikeyone/article/details/88342382</a></p>
<h2 id="sched-set-boot"><a href="#sched-set-boot" class="headerlink" title="sched_set_boot"></a>sched_set_boot</h2><p>sched_boost主要是通过影响Task placement的方式，来进行boost。计算每个cpu的负载，并将task分配到负载最轻的cpu上。如果有多个cpu的负载相同（一般是都处于idle），那么就会把task分配到系统中capacity最大的cpu上。通过设置节点：&#x2F;proc&#x2F;sys&#x2F;kernel&#x2F;sched_boost 或者内核调用 sched_set_boost()函数，可以进行sched_boost，并且在分配任务时，忽略对energy的消耗。和前面的CPUSet以及TaskSet很相识。具体请参考以下文章：<a target="_blank" rel="noopener" href="https://www.cnblogs.com/hellokitty2/p/13876132.html">https://www.cnblogs.com/hellokitty2/p/13876132.html</a></p>
<h2 id="启发"><a href="#启发" class="headerlink" title="启发"></a>启发</h2><ul>
<li>用不同场景下的CPU性能调度策略的算法作毕业设计。如对EAS的优化，对于重载情况如游戏场景下的CPU调度算法</li>
<li>使用GPT来优化调度算法</li>
<li>在c的层面或许不好优化算法，能不能在汇编语言层来优化呢</li>
<li>学习一项新技术的时候，主要在于连，多敲代码。建议建立一个终极的案例库。将知识点对应的案例代码整理到一块。要掌握技术整体的搭建框架与流程</li>
<li>我们若能发现一天和一生的关联，若能发现琐碎与宏大的关联，每个平凡的人都能创造属于自己的不凡。</li>
<li>怎么确定自己学会了，就是要捋清楚各种概念，以及相关逻辑；还有就是要能回答针对性的问题。这样才是彻底学会了</li>
<li>能不能参考lmkd优化内存的算法来设计CPU调度算法</li>
</ul>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2023-08-21</span><i class="fa fa-tag"></i><a class="tag" href="/tags/性能分析/" title="性能分析">性能分析 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" target="_blank" rel="noopener" href="http://twitter.com/home?status=,http://example.com/2023/08/21/安卓性能之CPU学习总结/,Hexo,安卓性能之CPU学习总结,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2023/08/21/%E8%87%AA%E5%AE%9A%E4%B9%89View%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/" title="自定义View学习总结">Post anterior</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2023/04/25/%E5%9F%BA%E4%BA%8EAndroid%E7%9A%84%E7%AE%80%E7%BA%A6%E8%AE%B0%E4%BA%8B%E6%9C%AC%E5%BC%80%E5%8F%91%E8%AF%A6%E7%BB%86%E6%96%87%E6%A1%A3/" title="基于Android的简约记事本开发详细文档">Post siguiente</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>